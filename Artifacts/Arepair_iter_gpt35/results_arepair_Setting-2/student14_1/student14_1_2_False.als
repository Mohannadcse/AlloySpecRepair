sig List { header: lone Node } sig Node { link: lone Node, elem: set Int } fact CardinalityConstraints { all l: List | lone l.header } fact NoLinkCycle { no n: Node | n in n.^link } pred Sorted[This: List]{ all n: This.header.*link | n.elem < n.link.elem } assert repair_assert_1 { all l: List | Sorted[l] <=> { all n: l.header.*link | some n.link => n.elem <= n.link.elem }} check repair_assert_1 pred repair_pred_1 { all l: List | Sorted[l] <=> { all n: l.header.*link | some n.link => n.elem <= n.link.elem }} run repair_pred_1 pred RepOk[This: List]{ Sorted[This] } pred Count[This: List, x: Int, result: Int]{ RepOk[This] result = #{ n: This.header.*link | x = n.elem } } pred Contains[This: List, x: Int, result: Boolean]{ RepOk[This] result = True <=> x in This.header.*link.elem } fact IGNORE { one List List.header.*link = Node }