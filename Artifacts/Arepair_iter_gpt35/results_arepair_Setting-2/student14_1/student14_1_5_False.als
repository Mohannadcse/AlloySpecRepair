sig List {header: lone Node} sig Node {link: lone Node, elem: set Int} fact CardinalityConstraints {all l: List | lone l.header} pred Loop(This: List){one n: This.header.*link | n in n.^link} pred Sorted(This: List){all n: This.header.*link | n.elem < n.link.elem} assert repair_assert_1 {all l: List | Sorted[l] <=> { all n: l.header.*link | some n.link => n.elem <= n.link.elem }} pred repair_pred_1 {all l: List | Sorted[l] <=> { all n: l.header.*link | some n.link => n.elem <= n.link.elem }} pred RepOk(This: List){Loop[This] Sorted[This]} pred Count(This: List, x: Int, result: Int){RepOk[This] result = #{ n: This.header.*link | x = n.elem }} abstract sig Boolean {} one sig True, False extends Boolean {} pred Contains(This: List, x: Int, result: Boolean) {RepOk[This] result = True <=> x in This.header.*link.elem} fact IGNORE {one List List.header.*link = Node}