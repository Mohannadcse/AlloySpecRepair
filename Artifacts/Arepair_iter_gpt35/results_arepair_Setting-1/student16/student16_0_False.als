sig List { header: set Node } sig Node { link: set Node, elem: set Int } fact CardinalityConstraints { all l: List | lone l.header all n: Node | lone n.link all n: Node | one n.elem } pred Loop(This: List) {} assert repair_assert_1{ all l : List | Loop[l] <=> {no l.header or one n: l.header.*link | n = n.link} } pred repair_pred_1{ all l : List | Loop[l] <=> {no l.header or one n: l.header.*link | n = n.link} } pred Sorted(This: List) {} pred RepOk(This: List) { Loop[This] Sorted[This] } pred Count(This: List, x: Int, result: Int) { RepOk[This] } abstract sig Boolean {} one sig True, False extends Boolean {} pred Contains(This: List, x: Int, result: Boolean) { RepOk[This] } fact IGNORE { one List List.header.*link = Node }